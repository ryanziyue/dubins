diff --git a/dubins_graph.py b/dubins_graph.py
index 8a0fc23..01be409 100644
--- a/dubins_graph.py
+++ b/dubins_graph.py
@@ -39,10 +39,10 @@ def next_point(event):
 
 # iterates through and finds the shortest (optimal) route
 def find_best(paths):
-    shortest = paths[0][0]
+    shortest = paths[0][1][0]
     ind = 0
     for i in range(len(paths)):
-        if paths[i][0] < shortest:
+        if paths[i][1][0] < shortest:
             ind = i
 
     return ind
@@ -83,30 +83,30 @@ def find_path(ax):
 
     # CCC paths only work if drone & waypoint within 4 turn-radii
     if (dist < 4 * TURNRADIUS):
-        try: paths.append(RLR(drone_right, point_right, drone_pos, point_pos, TURNRADIUS))
+        try: paths.append(("RLR", RLR(drone_right, point_right, drone_pos, point_pos, TURNRADIUS)))
         except: pass
 
-        try: paths.append(LRL(drone_left, point_left, drone_pos, point_pos, TURNRADIUS))
+        try: paths.append(("LRL", LRL(drone_left, point_left, drone_pos, point_pos, TURNRADIUS)))
         except: pass
 
     # CSC paths only work if drone & waypoint are at least 2 turn-radii apart
     if (dist > 2 * TURNRADIUS):
-        try: paths.append(RSR(drone_right, point_right, drone_pos, point_pos, TURNRADIUS))
+        try: paths.append(("RSR", RSR(drone_right, point_right, drone_pos, point_pos, TURNRADIUS)))
         except: pass
 
-        try: paths.append(LSL(drone_left, point_left, drone_pos, point_pos, TURNRADIUS))
+        try: paths.append(("LSL", LSL(drone_left, point_left, drone_pos, point_pos, TURNRADIUS)))
         except: pass
 
-        try: paths.append(RSL(drone_right, point_left, drone_pos, point_pos, TURNRADIUS))
+        try: paths.append(("RSL", RSL(drone_right, point_left, drone_pos, point_pos, TURNRADIUS)))
         except: pass
 
-        try: paths.append(LSR(drone_left, point_right, drone_pos, point_pos, TURNRADIUS))
+        try: paths.append(("LSR", LSR(drone_left, point_right, drone_pos, point_pos, TURNRADIUS)))
         except: pass
 
     best_path = paths[find_best(paths)]
 
     if not DISCRETIZE_FLAG:
-        line_draw(best_path)
+        line_draw(best_path[1])
     else:
         dot_draw(best_path)
 
@@ -139,9 +139,10 @@ def increments(angle):
     return int(angle * 180 / PI // 30) + 1 # one point every 20 degrees
 
 # draws the path as a series of discretized points
-def dot_draw(path):
+def dot_draw(pathData):
     # array of points for drone
     points = []
+    path = pathData[1]
 
     if path[1] == "CSC":
         # start/end angles for drone arc
@@ -236,6 +237,11 @@ def dot_draw(path):
             ax.plot(temp_x, temp_y, color='purple', marker='.')
             points.append([temp_x, temp_y])
 
+    if pathData[0] == "LRL" or pathData[0] == "LSR" or pathData[0] == "LSL":
+        points = points[1:]
+
+    print(drone_pos)
+    print(points)
     return points
 
 # redraws canvas to include new waypoint + vector
